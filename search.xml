<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>矩阵增量式求逆</title>
      <link href="/2020/03/15/ju-zhen-zeng-liang-shi-qiu-ni/"/>
      <url>/2020/03/15/ju-zhen-zeng-liang-shi-qiu-ni/</url>
      
        <content type="html"><![CDATA[<p>本文只讨论 <strong>狭义</strong>的<strong>可逆</strong>矩阵，首先必须是<strong>方阵</strong>。</p><h2 id="sec:1">背景&amp;动机</h2><p>暴力求一个矩阵的逆，时间复杂度是<span class="math inline">\(O(n^3)\)</span>，太高了。如果这个矩阵会随着时间越长越大，每长一次就要求一次逆，如何降低计算开销？再如果这个矩阵不光变大，还有可能缩小，又如何处理？</p><p>一个典型的场景是在线计算核矩阵的逆<span class="citation" data-cites="wu2017online cauwenberghs2001incremental">(Wu et al. <a href="#ref-wu2017online" role="doc-biblioref">2017</a>; Cauwenberghs and Poggio <a href="#ref-cauwenberghs2001incremental" role="doc-biblioref">2001</a>)</span>。</p><h2 id="背景知识">背景知识</h2><p>假设某可逆矩阵，分为<span class="math inline">\(A,B,C,D\)</span>四块，则有公式可以计算该分块矩阵的逆。按照子矩阵形状的不同，可分为如下两种情况：</p><p><del>公式有点多，不要怕，真的</del></p><ol type="1"><li><span class="math inline">\(A, D\)</span>为方阵：</li></ol><p><span id="eq:1"><span class="math display">\[\begin{align}    \begin{split}        \left[ \begin{array}{cc}        A &amp; B \\        C &amp; D \\        \end{array} \right]^{-1}        &amp;=        \left[ \begin{array}{cc}        A^{-1}+A^{-1}BFCA^{-1} &amp; -A^{-1}BF \\        -FCA^{-1} &amp; F \\        \end{array} \right]\\        \text{where}\qquad F&amp;=(D-CA^{-1}B)^{-1}    \end{split}\end{align}\qquad(1)\]</span></span></p><p>公式 1 等价于：</p><p><span id="eq:2"><span class="math display">\[\begin{align}    \begin{split}        \left[ \begin{array}{cc}        A &amp; B \\        C &amp; D \\        \end{array} \right]^{-1}        &amp;=        \left[ \begin{array}{cc}        E &amp; -EBD^{-1} \\        -D^{-1}CE &amp; D^{-1}+D^{-1}CEBD^{-1} \\        \end{array} \right]\\        \text{where}\qquad E&amp;=(A-BD^{-1}C)^{-1}    \end{split}\end{align}\qquad(2)\]</span></span></p><!-- --><ol start="2" type="1"><li><span class="math inline">\(B, C\)</span>为方阵：</li></ol><p><span id="eq:3"><span class="math display">\[\begin{align}    \begin{split}        \left[ \begin{array}{cc}        A &amp; B \\        C &amp; D \\        \end{array} \right]^{-1}        &amp;=        \left[ \begin{array}{cc}        -GDB^{-1} &amp; G \\        B^{-1}+B^{-1}AGDB^{-1} &amp; -BAG \\        \end{array} \right]\\        \text{where}\qquad G&amp;=(C-DB^{-1}A)^{-1}    \end{split}\end{align}\qquad(3)\]</span></span></p><p>公式 3 也有等价形式：</p><p><span id="eq:4"><span class="math display">\[\begin{align}    \begin{split}        \left[ \begin{array}{cc}        A &amp; B \\        C &amp; D \\        \end{array} \right]^{-1}        &amp;=        \left[ \begin{array}{cc}        -C^{-1}DH &amp; C^{-1}+C^{-1}DHAC^{-1} \\        H &amp; -HAC^{-1} \\        \end{array} \right]\\        \text{where}\qquad H&amp;=(B-AC^{-1}D)^{-1}    \end{split}\end{align}\qquad(4)\]</span></span></p><h2 id="sec:3">如何做</h2><p>有了上述四个公式，即可增量计算矩阵逆。举例如下：</p><blockquote><p>假设现在有一矩阵 <span class="math inline">\(A\in\mathbb{R}^{n\times n}\)</span>，已知其逆矩阵 <span class="math inline">\(A^{-1}\)</span>，如果：在<span class="math inline">\(A\)</span>右侧添加子矩阵<span class="math inline">\(B\in\mathbb{R}^{n\times m}\)</span>，下方添加子矩阵<span class="math inline">\(C\in\mathbb{R}^{m\times n}\)</span>，右下方添加子矩阵<span class="math inline">\(D\in\mathbb{R}^{m\times m}\)</span>，构成大矩阵 <span class="math inline">\(A&#39;\in\mathbb{R}^{(n+m)\times (n+m)}\)</span>，求<span class="math inline">\(A&#39;\)</span>的逆。</p></blockquote><p>这个问题是矩阵扩张的情形，可以直接应用 公式 1 解决。那么问题反过来，缩小如何解决？</p><blockquote><p>已知矩阵<span class="math inline">\(A&#39;\in\mathbb{R}^{n\times n}\)</span>是矩阵<span class="math inline">\(A\)</span>的逆，若在<span class="math inline">\(A\)</span>（以及<span class="math inline">\(A&#39;\)</span>）的左上两边各舍弃<span class="math inline">\(m\)</span>列，求<span class="math inline">\(A\)</span>剩下的子矩阵的逆。</p></blockquote><p>稍微多了点步骤，这相当于：已知 公式 2 的右边，删去了左上角的<span class="math inline">\(m\)</span>行/列，求<span class="math inline">\(D^{-1}\)</span>。还可以注意到： * <span class="math inline">\(A&#39;\)</span> 剩下的东西就相当于是 公式 2 右边的 <span class="math inline">\(D^{-1}+D^{-1}CEBD^{-1}\)</span> * 左边删去的相当于是<span class="math inline">\(-D^{-1}CE\)</span> * 上边删去的相当于是 <span class="math inline">\(-EBD^{-1}\)</span> * 左上角删去的是 <span class="math inline">\(E\)</span></p><p>另外把 <span class="math inline">\(D^{-1}C\)</span> 与 <span class="math inline">\(BD^{-1}\)</span> 分别看成整体，可以建立方程组求出<span class="math inline">\(D^{-1}\)</span>来：</p><p><span class="math display">\[\begin{split}    \text{左上删去的部分} = E      \\    -[D^{-1}C]E = \text{左边删去的} \\    -E[BD^{-1}] = \text{上边删去的} \\    D^{-1} =  \text{剩下的} - [D^{-1}C]E[BD^{-1}]\end{split}\]</span> 把<span class="math inline">\(D^{-1}C\)</span>、<span class="math inline">\(BD^{-1}\)</span>当整体解出来，带到第4个公式里，即可得到<span class="math inline">\(D^{-1}\)</span>。</p><h2 id="总结">总结</h2><p>前面举例介绍了在已知矩阵的右下角新增行列时如何求逆，以及从已知矩阵的左上角删除行列时如何求逆。分别是 公式 1 正用， 公式 2 反用的情况。</p><p>不难发现，公式 1-4 正着用就分别适用于已知 <span class="math inline">\(A^{-1}, D^{-1}, B^{-1}, C^{-1}\)</span>，求大矩阵的逆；而反着用就分别适用于已知大矩阵的逆，求对应剩余部分的逆的情况。当然了，这样做省时间的前提是要<span class="math inline">\(m\ll n\)</span>，不然求<span class="math inline">\(m\times m\)</span>大小的矩阵的逆也是很花时间的，得不偿失了。</p><pre id="main_code" class="lang-python"><code>def inverse_enlarge(iA, B, C, D, where=&#39;TL&#39;):    &#39;&#39;&#39;    已知iA为某方阵A的逆，在A周围新添加BCD三块，组成新方阵。返回该新方阵的逆。    where: 指示iA的位置，即在大方阵的哪个角。    BCD的位置按照如下原则：A与B在同一行。A的对角是D。剩余的是C。A与D始终是方阵。    &#39;&#39;&#39;    assert(iA.shape[0]==B.shape[0])    assert(iA.shape[1]==C.shape[1])    assert(D.shape[0]==C.shape[0])    assert(D.shape[1]==B.shape[1])    assert(iA.shape[0]==iA.shape[1] and D.shape[0]==D.shape[1])    F = np.linalg.inv(D-C@iA@B)    Ap = iA+iA@B@F@C@iA    Bp = -iA@B@F    Cp = -F@C@iA    if where == &#39;BR&#39;:        return np.asarray(np.bmat([[F, Cp],[Bp, Ap]]))    elif where == &#39;TL&#39;:        return np.asarray(np.bmat([[Ap, Bp],[Cp, F]]))    elif where == &#39;TR&#39;:        return np.asarray(np.bmat([[Cp, F],[Ap, Bp]]))    else:        assert(where == &#39;BL&#39;)        return np.asarray(np.bmat([[Bp, Ap],[F, Cp]]))def inverse_shrink(V, m, where=&#39;BR&#39;):    &#39;&#39;&#39;    已知V为某分块矩阵的逆，求某个子方阵的逆。限制：V与要求的子矩阵都必须是方阵。    V: 已知的逆矩阵    m: 返回值大小为&lt;m x m&gt;    where: 返回值在大矩阵的哪个角。    &#39;&#39;&#39;    assert(V.shape[0]==V.shape[1] and V.shape[0]&gt;m&gt;0)    if where==&#39;BR&#39;:        F, Cp, Bp, X = V[:-m, :-m], V[:-m, -m:], V[-m:, :-m], V[-m:, -m:]    elif where==&#39;TL&#39;:        X, Bp, Cp, F = V[:m, :m], V[:m, m:], V[m:, :m], V[m:, m:]    elif where==&#39;TR&#39;:        m = V.shape[0]-m        Cp, F, X, Bp = V[:m, :-m], V[:m, -m:], V[m:, :-m], V[m:, -m:]    else:        assert(where==&#39;BL&#39;)        m = V.shape[0]-m        Bp, X, F, Cp = V[:-m, :m], V[:-m, m:], V[-m:, :m], V[-m:, m:]    tmp = np.linalg.inv(F)    CiA = tmp@Cp    iAB = Bp@tmp    iA = X-iAB@F@CiA    return iA</code></pre><p>测试代码</p><pre id="test_code" class="lang-python"><code>A = np.random.randn(5,5)B = np.random.randn(5,1)C = np.random.randn(1,5)D = np.random.randn(1,1)iA = np.linalg.inv(A)Q = np.asarray(np.bmat( [[D, C],[B,A]] ))iQ = inverse_enlarge(iA, B, C, D, &#39;BR&#39;)print(np.allclose(iQ, np.linalg.inv(Q) ))Q = np.asarray(np.bmat( [[A, B],[C,D]] ))iQ = inverse_enlarge(iA, B, C, D, &#39;TL&#39;)print(np.allclose(iQ, np.linalg.inv(Q) ))Q = np.asarray(np.bmat( [[B, A],[D,C]] ))iQ = inverse_enlarge(iA, B, C, D, &#39;TR&#39;)print(np.allclose(iQ, np.linalg.inv(Q) ))Q = np.asarray(np.bmat( [[C, D],[A,B]] ))iQ = inverse_enlarge(iA, B, C, D, &#39;BL&#39;)print(np.allclose(iQ, np.linalg.inv(Q) ))A = np.random.randn(1,1)B = np.random.randn(1,5)C = np.random.randn(5,1)D = np.random.randn(5,5)iQ = np.linalg.inv(np.asarray(np.bmat( [[A, B],[C,D]] )))iD = inverse_shrink(iQ, 5, &#39;BR&#39;)print(np.allclose(iD, np.linalg.inv(D)))iQ = np.linalg.inv(np.asarray(np.bmat( [[D, C],[B,A]] )))iD = inverse_shrink(iQ, 5, &#39;TL&#39;)print(np.allclose(iD, np.linalg.inv(D)))iQ = np.linalg.inv(np.asarray(np.bmat( [[C, D],[A,B]] )))iD = inverse_shrink(iQ, 5, &#39;TR&#39;)print(np.allclose(iD, np.linalg.inv(D)))iQ = np.linalg.inv(np.asarray(np.bmat( [[B, A],[D,C]] )))iD = inverse_shrink(iQ, 5, &#39;BL&#39;)print(np.allclose(iD, np.linalg.inv(D)))</code></pre><h2 id="参考文献">参考文献</h2><div id="refs" class="references hanging-indent" role="doc-bibliography"><p><a href="https://www.zhihu.com/question/47760591" target="_blank" rel="noopener">知乎：如何求一个矩阵的逆</a></p><p><a href="http://www.cs.ubbcluj.ro/~csatol/SOGP/thesis/Iterative_computation.html" target="_blank" rel="noopener" class="uri">http://www.cs.ubbcluj.ro/~csatol/SOGP/thesis/Iterative_computation.html</a></p><div id="ref-cauwenberghs2001incremental"><p>Cauwenberghs, Gert, and Tomaso Poggio. 2001. “Incremental and Decremental Support Vector Machine Learning.” In <em>Advances in Neural Information Processing Systems</em>, 409–15.</p></div><div id="ref-wu2017online"><p>Wu, Chung-Hao, Wei-Chen His, Henry Horng-Shing Lu, and Hsueh-Ming Hang. 2017. “Online Multiclass Passive-Aggressive Learning on a Fixed Budget.” In <em>2017 Ieee International Symposium on Circuits and Systems (Iscas)</em>, 1–4. IEEE.</p></div></div>]]></content>
      
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python的GIL</title>
      <link href="/2020/03/15/python-de-gil/"/>
      <url>/2020/03/15/python-de-gil/</url>
      
        <content type="html"><![CDATA[<p>GIL全称Python Global Interpreter Lock，全局解释器锁。</p><h2 id="gil解决的问题">GIL解决的问题</h2><p>为了维护 python 变量的引用计数，该引用计数将用于垃圾收集。 同一进程内，多个解释器同时更新引用计数将产生竞争条件（race condition）。 在执行python字节码时需要保证线程安全。</p><h2 id="为何python选择了gil作为解决方案">为何Python选择了GIL作为解决方案</h2><ol type="1"><li>在操作系统还没有线程概念的时候，Python就已经出现了；</li><li>能提供线程安全的内存管理（垃圾收集）；</li><li>易于实现，是python早期的设计者们所采用的解决复杂问题的简单方法。</li></ol><h2 id="gil带来的问题">GIL带来的问题</h2><p>GIL的直接结果就是一个python进程只有一个解释器，从而导致一个python进程的多线程部分只能有一个解释器真正在执行。 对于CPU密集型任务，无法利用多核进行计算加速。</p><h2 id="如何避免">如何避免</h2><ol type="1"><li><p>使用多进程而不是多线程。即：使用multiprocessing库而不是自带的threading。前者启的是进程，后者启的是线程。</p></li><li><p>换用其他的py解释器。IronPython没有GIL。</p></li></ol><h2 id="参考">参考</h2><p><a href="https://realpython.com/python-gil/" target="_blank" rel="noopener" class="uri">https://realpython.com/python-gil/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
