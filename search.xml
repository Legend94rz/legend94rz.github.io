<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>矩阵增量式求逆</title>
      <link href="/2020/03/15/ju-zhen-zeng-liang-shi-qiu-ni/"/>
      <url>/2020/03/15/ju-zhen-zeng-liang-shi-qiu-ni/</url>
      
        <content type="html"><![CDATA[<p>本文只讨论 <strong>狭义</strong>的<strong>可逆</strong>矩阵，首先必须是<strong>方阵</strong>。</p><h2 id="sec:1">背景&amp;动机</h2><p>暴力求一个矩阵的逆，时间复杂度是<span class="math inline">\(O(n^3)\)</span>，太高了。如果这个矩阵会随着时间越长越大，每长一次就要求一次逆，如何降低计算开销？再如果这个矩阵不光变大，还有可能缩小，又如何处理？</p><p>一个典型的场景是在线计算核矩阵的逆<span class="citation" data-cites="wu2017online cauwenberghs2001incremental">(Wu et al. <a href="#ref-wu2017online" role="doc-biblioref">2017</a>; Cauwenberghs and Poggio <a href="#ref-cauwenberghs2001incremental" role="doc-biblioref">2001</a>)</span>。</p><h2 id="背景知识">背景知识</h2><p>假设某可逆矩阵，分为<span class="math inline">\(A,B,C,D\)</span>四块，则有公式可以计算该分块矩阵的逆。按照子矩阵形状的不同，可分为如下两种情况：</p><p><del>公式有点多，不要怕，真的</del></p><ol type="1"><li><span class="math inline">\(A, D\)</span>为方阵：</li></ol><p><span id="eq:1"><span class="math display">\[\begin{align}    \begin{split}        \left[ \begin{array}{cc}        A &amp; B \\        C &amp; D \\        \end{array} \right]^{-1}        &amp;=        \left[ \begin{array}{cc}        A^{-1}+A^{-1}BFCA^{-1} &amp; -A^{-1}BF \\        -FCA^{-1} &amp; F \\        \end{array} \right]\\        \text{where}\qquad F&amp;=(D-CA^{-1}B)^{-1}    \end{split}\end{align}\qquad(1)\]</span></span></p><p>公式&nbsp;1 等价于：</p><p><span id="eq:2"><span class="math display">\[\begin{align}    \begin{split}        \left[ \begin{array}{cc}        A &amp; B \\        C &amp; D \\        \end{array} \right]^{-1}        &amp;=        \left[ \begin{array}{cc}        E &amp; -EBD^{-1} \\        -D^{-1}CE &amp; D^{-1}+D^{-1}CEBD^{-1} \\        \end{array} \right]\\        \text{where}\qquad E&amp;=(A-BD^{-1}C)^{-1}    \end{split}\end{align}\qquad(2)\]</span></span></p><!-- --><ol start="2" type="1"><li><span class="math inline">\(B, C\)</span>为方阵：</li></ol><p><span id="eq:3"><span class="math display">\[\begin{align}    \begin{split}        \left[ \begin{array}{cc}        A &amp; B \\        C &amp; D \\        \end{array} \right]^{-1}        &amp;=        \left[ \begin{array}{cc}        -GDB^{-1} &amp; G \\        B^{-1}+B^{-1}AGDB^{-1} &amp; -BAG \\        \end{array} \right]\\        \text{where}\qquad G&amp;=(C-DB^{-1}A)^{-1}    \end{split}\end{align}\qquad(3)\]</span></span></p><p>公式&nbsp;3 也有等价形式：</p><p><span id="eq:4"><span class="math display">\[\begin{align}    \begin{split}        \left[ \begin{array}{cc}        A &amp; B \\        C &amp; D \\        \end{array} \right]^{-1}        &amp;=        \left[ \begin{array}{cc}        -C^{-1}DH &amp; C^{-1}+C^{-1}DHAC^{-1} \\        H &amp; -HAC^{-1} \\        \end{array} \right]\\        \text{where}\qquad H&amp;=(B-AC^{-1}D)^{-1}    \end{split}\end{align}\qquad(4)\]</span></span></p><h2 id="sec:3">如何做</h2><p>有了上述四个公式，即可增量计算矩阵逆。举例如下：</p><blockquote><p>假设现在有一矩阵 <span class="math inline">\(A\in\mathbb{R}^{n\times n}\)</span>，已知其逆矩阵 <span class="math inline">\(A^{-1}\)</span>，如果：在<span class="math inline">\(A\)</span>右侧添加子矩阵<span class="math inline">\(B\in\mathbb{R}^{n\times m}\)</span>，下方添加子矩阵<span class="math inline">\(C\in\mathbb{R}^{m\times n}\)</span>，右下方添加子矩阵<span class="math inline">\(D\in\mathbb{R}^{m\times m}\)</span>，构成大矩阵 <span class="math inline">\(A'\in\mathbb{R}^{(n+m)\times (n+m)}\)</span>，求<span class="math inline">\(A'\)</span>的逆。</p></blockquote><p>这个问题是矩阵扩张的情形，可以直接应用 公式&nbsp;1 解决。那么问题反过来，缩小如何解决？</p><blockquote><p>已知矩阵<span class="math inline">\(A'\in\mathbb{R}^{n\times n}\)</span>是矩阵<span class="math inline">\(A\)</span>的逆，若在<span class="math inline">\(A\)</span>（以及<span class="math inline">\(A'\)</span>）的左上两边各舍弃<span class="math inline">\(m\)</span>列，求<span class="math inline">\(A\)</span>剩下的子矩阵的逆。</p></blockquote><p>稍微多了点步骤，这相当于：已知 公式&nbsp;2 的右边，删去了左上角的<span class="math inline">\(m\)</span>行/列，求<span class="math inline">\(D^{-1}\)</span>。还可以注意到： * <span class="math inline">\(A'\)</span> 剩下的东西就相当于是 公式&nbsp;2 右边的 <span class="math inline">\(D^{-1}+D^{-1}CEBD^{-1}\)</span> * 左边删去的相当于是<span class="math inline">\(-D^{-1}CE\)</span> * 上边删去的相当于是 <span class="math inline">\(-EBD^{-1}\)</span> * 左上角删去的是 <span class="math inline">\(E\)</span></p><p>另外把 <span class="math inline">\(D^{-1}C\)</span> 与 <span class="math inline">\(BD^{-1}\)</span> 分别看成整体，可以建立方程组求出<span class="math inline">\(D^{-1}\)</span>来：</p><p><span class="math display">\[\begin{split}    \text{左上删去的部分} = E      \\    -[D^{-1}C]E = \text{左边删去的} \\    -E[BD^{-1}] = \text{上边删去的} \\    D^{-1} =  \text{剩下的} - [D^{-1}C]E[BD^{-1}]\end{split}\]</span> 把<span class="math inline">\(D^{-1}C\)</span>、<span class="math inline">\(BD^{-1}\)</span>当整体解出来，带到第4个公式里，即可得到<span class="math inline">\(D^{-1}\)</span>。</p><h2 id="总结">总结</h2><p>前面举例介绍了在已知矩阵的右下角新增行列时如何求逆，以及从已知矩阵的左上角删除行列时如何求逆。分别是 公式&nbsp;1 正用， 公式&nbsp;2 反用的情况。</p><p>不难发现，公式&nbsp;1-4 正着用就分别适用于已知 <span class="math inline">\(A^{-1}, D^{-1}, B^{-1}, C^{-1}\)</span>，求大矩阵的逆；而反着用就分别适用于已知大矩阵的逆，求对应剩余部分的逆的情况。当然了，这样做省时间的前提是要<span class="math inline">\(m\ll n\)</span>，不然求<span class="math inline">\(m\times m\)</span>大小的矩阵的逆也是很花时间的，得不偿失了。</p><div class="sourceCode" id="main_code"><pre class="sourceCode python"><code class="sourceCode python"><span id="main_code-1"><a href="#main_code-1"></a><span class="kw">def</span> inverse_enlarge(iA, B, C, D, where<span class="op">=</span><span class="st">'TL'</span>):</span><span id="main_code-2"><a href="#main_code-2"></a>    <span class="co">'''</span></span><span id="main_code-3"><a href="#main_code-3"></a><span class="co">    已知iA为某方阵A的逆，在A周围新添加BCD三块，组成新方阵。返回该新方阵的逆。</span></span><span id="main_code-4"><a href="#main_code-4"></a><span class="co">    where: 指示iA的位置，即在大方阵的哪个角。</span></span><span id="main_code-5"><a href="#main_code-5"></a><span class="co">    BCD的位置按照如下原则：A与B在同一行。A的对角是D。剩余的是C。A与D始终是方阵。</span></span><span id="main_code-6"><a href="#main_code-6"></a><span class="co">    '''</span></span><span id="main_code-7"><a href="#main_code-7"></a>    <span class="cf">assert</span>(iA.shape[<span class="dv">0</span>]<span class="op">==</span>B.shape[<span class="dv">0</span>])</span><span id="main_code-8"><a href="#main_code-8"></a>    <span class="cf">assert</span>(iA.shape[<span class="dv">1</span>]<span class="op">==</span>C.shape[<span class="dv">1</span>])</span><span id="main_code-9"><a href="#main_code-9"></a>    <span class="cf">assert</span>(D.shape[<span class="dv">0</span>]<span class="op">==</span>C.shape[<span class="dv">0</span>])</span><span id="main_code-10"><a href="#main_code-10"></a>    <span class="cf">assert</span>(D.shape[<span class="dv">1</span>]<span class="op">==</span>B.shape[<span class="dv">1</span>])</span><span id="main_code-11"><a href="#main_code-11"></a>    <span class="cf">assert</span>(iA.shape[<span class="dv">0</span>]<span class="op">==</span>iA.shape[<span class="dv">1</span>] <span class="kw">and</span> D.shape[<span class="dv">0</span>]<span class="op">==</span>D.shape[<span class="dv">1</span>])</span><span id="main_code-12"><a href="#main_code-12"></a>    F <span class="op">=</span> np.linalg.inv(D<span class="op">-</span>C<span class="op">@</span>iA<span class="op">@</span>B)</span><span id="main_code-13"><a href="#main_code-13"></a>    Ap <span class="op">=</span> iA<span class="op">+</span>iA<span class="op">@</span>B<span class="op">@</span>F<span class="op">@</span>C<span class="op">@</span>iA</span><span id="main_code-14"><a href="#main_code-14"></a>    Bp <span class="op">=</span> <span class="op">-</span>iA<span class="op">@</span>B<span class="op">@</span>F</span><span id="main_code-15"><a href="#main_code-15"></a>    Cp <span class="op">=</span> <span class="op">-</span>F<span class="op">@</span>C<span class="op">@</span>iA</span><span id="main_code-16"><a href="#main_code-16"></a>    <span class="cf">if</span> where <span class="op">==</span> <span class="st">'BR'</span>:</span><span id="main_code-17"><a href="#main_code-17"></a>        <span class="cf">return</span> np.asarray(np.bmat([[F, Cp],[Bp, Ap]]))</span><span id="main_code-18"><a href="#main_code-18"></a>    <span class="cf">elif</span> where <span class="op">==</span> <span class="st">'TL'</span>:</span><span id="main_code-19"><a href="#main_code-19"></a>        <span class="cf">return</span> np.asarray(np.bmat([[Ap, Bp],[Cp, F]]))</span><span id="main_code-20"><a href="#main_code-20"></a>    <span class="cf">elif</span> where <span class="op">==</span> <span class="st">'TR'</span>:</span><span id="main_code-21"><a href="#main_code-21"></a>        <span class="cf">return</span> np.asarray(np.bmat([[Cp, F],[Ap, Bp]]))</span><span id="main_code-22"><a href="#main_code-22"></a>    <span class="cf">else</span>:</span><span id="main_code-23"><a href="#main_code-23"></a>        <span class="cf">assert</span>(where <span class="op">==</span> <span class="st">'BL'</span>)</span><span id="main_code-24"><a href="#main_code-24"></a>        <span class="cf">return</span> np.asarray(np.bmat([[Bp, Ap],[F, Cp]]))</span><span id="main_code-25"><a href="#main_code-25"></a></span><span id="main_code-26"><a href="#main_code-26"></a><span class="kw">def</span> inverse_shrink(V, m, where<span class="op">=</span><span class="st">'BR'</span>):</span><span id="main_code-27"><a href="#main_code-27"></a>    <span class="co">'''</span></span><span id="main_code-28"><a href="#main_code-28"></a><span class="co">    已知V为某分块矩阵的逆，求某个子方阵的逆。限制：V与要求的子矩阵都必须是方阵。</span></span><span id="main_code-29"><a href="#main_code-29"></a><span class="co">    V: 已知的逆矩阵</span></span><span id="main_code-30"><a href="#main_code-30"></a><span class="co">    m: 返回值大小为&lt;m x m&gt;</span></span><span id="main_code-31"><a href="#main_code-31"></a><span class="co">    where: 返回值在大矩阵的哪个角。</span></span><span id="main_code-32"><a href="#main_code-32"></a><span class="co">    '''</span></span><span id="main_code-33"><a href="#main_code-33"></a>    <span class="cf">assert</span>(V.shape[<span class="dv">0</span>]<span class="op">==</span>V.shape[<span class="dv">1</span>] <span class="kw">and</span> V.shape[<span class="dv">0</span>]<span class="op">&gt;</span>m<span class="op">&gt;</span><span class="dv">0</span>)</span><span id="main_code-34"><a href="#main_code-34"></a>    <span class="cf">if</span> where<span class="op">==</span><span class="st">'BR'</span>:</span><span id="main_code-35"><a href="#main_code-35"></a>        F, Cp, Bp, X <span class="op">=</span> V[:<span class="op">-</span>m, :<span class="op">-</span>m], V[:<span class="op">-</span>m, <span class="op">-</span>m:], V[<span class="op">-</span>m:, :<span class="op">-</span>m], V[<span class="op">-</span>m:, <span class="op">-</span>m:]</span><span id="main_code-36"><a href="#main_code-36"></a>    <span class="cf">elif</span> where<span class="op">==</span><span class="st">'TL'</span>:</span><span id="main_code-37"><a href="#main_code-37"></a>        X, Bp, Cp, F <span class="op">=</span> V[:m, :m], V[:m, m:], V[m:, :m], V[m:, m:]</span><span id="main_code-38"><a href="#main_code-38"></a>    <span class="cf">elif</span> where<span class="op">==</span><span class="st">'TR'</span>:</span><span id="main_code-39"><a href="#main_code-39"></a>        m <span class="op">=</span> V.shape[<span class="dv">0</span>]<span class="op">-</span>m</span><span id="main_code-40"><a href="#main_code-40"></a>        Cp, F, X, Bp <span class="op">=</span> V[:m, :<span class="op">-</span>m], V[:m, <span class="op">-</span>m:], V[m:, :<span class="op">-</span>m], V[m:, <span class="op">-</span>m:]</span><span id="main_code-41"><a href="#main_code-41"></a>    <span class="cf">else</span>:</span><span id="main_code-42"><a href="#main_code-42"></a>        <span class="cf">assert</span>(where<span class="op">==</span><span class="st">'BL'</span>)</span><span id="main_code-43"><a href="#main_code-43"></a>        m <span class="op">=</span> V.shape[<span class="dv">0</span>]<span class="op">-</span>m</span><span id="main_code-44"><a href="#main_code-44"></a>        Bp, X, F, Cp <span class="op">=</span> V[:<span class="op">-</span>m, :m], V[:<span class="op">-</span>m, m:], V[<span class="op">-</span>m:, :m], V[<span class="op">-</span>m:, m:]</span><span id="main_code-45"><a href="#main_code-45"></a>    tmp <span class="op">=</span> np.linalg.inv(F)</span><span id="main_code-46"><a href="#main_code-46"></a>    CiA <span class="op">=</span> tmp<span class="op">@</span>Cp</span><span id="main_code-47"><a href="#main_code-47"></a>    iAB <span class="op">=</span> Bp<span class="op">@</span>tmp</span><span id="main_code-48"><a href="#main_code-48"></a>    iA <span class="op">=</span> X<span class="op">-</span>iAB<span class="op">@</span>F<span class="op">@</span>CiA</span><span id="main_code-49"><a href="#main_code-49"></a>    <span class="cf">return</span> iA</span></code></pre></div><p>测试代码</p><div class="sourceCode" id="test_code"><pre class="sourceCode python"><code class="sourceCode python"><span id="test_code-1"><a href="#test_code-1"></a>A <span class="op">=</span> np.random.randn(<span class="dv">5</span>,<span class="dv">5</span>)</span><span id="test_code-2"><a href="#test_code-2"></a>B <span class="op">=</span> np.random.randn(<span class="dv">5</span>,<span class="dv">1</span>)</span><span id="test_code-3"><a href="#test_code-3"></a>C <span class="op">=</span> np.random.randn(<span class="dv">1</span>,<span class="dv">5</span>)</span><span id="test_code-4"><a href="#test_code-4"></a>D <span class="op">=</span> np.random.randn(<span class="dv">1</span>,<span class="dv">1</span>)</span><span id="test_code-5"><a href="#test_code-5"></a>iA <span class="op">=</span> np.linalg.inv(A)</span><span id="test_code-6"><a href="#test_code-6"></a></span><span id="test_code-7"><a href="#test_code-7"></a>Q <span class="op">=</span> np.asarray(np.bmat( [[D, C],[B,A]] ))</span><span id="test_code-8"><a href="#test_code-8"></a>iQ <span class="op">=</span> inverse_enlarge(iA, B, C, D, <span class="st">'BR'</span>)</span><span id="test_code-9"><a href="#test_code-9"></a><span class="bu">print</span>(np.allclose(iQ, np.linalg.inv(Q) ))</span><span id="test_code-10"><a href="#test_code-10"></a></span><span id="test_code-11"><a href="#test_code-11"></a>Q <span class="op">=</span> np.asarray(np.bmat( [[A, B],[C,D]] ))</span><span id="test_code-12"><a href="#test_code-12"></a>iQ <span class="op">=</span> inverse_enlarge(iA, B, C, D, <span class="st">'TL'</span>)</span><span id="test_code-13"><a href="#test_code-13"></a><span class="bu">print</span>(np.allclose(iQ, np.linalg.inv(Q) ))</span><span id="test_code-14"><a href="#test_code-14"></a></span><span id="test_code-15"><a href="#test_code-15"></a>Q <span class="op">=</span> np.asarray(np.bmat( [[B, A],[D,C]] ))</span><span id="test_code-16"><a href="#test_code-16"></a>iQ <span class="op">=</span> inverse_enlarge(iA, B, C, D, <span class="st">'TR'</span>)</span><span id="test_code-17"><a href="#test_code-17"></a><span class="bu">print</span>(np.allclose(iQ, np.linalg.inv(Q) ))</span><span id="test_code-18"><a href="#test_code-18"></a></span><span id="test_code-19"><a href="#test_code-19"></a>Q <span class="op">=</span> np.asarray(np.bmat( [[C, D],[A,B]] ))</span><span id="test_code-20"><a href="#test_code-20"></a>iQ <span class="op">=</span> inverse_enlarge(iA, B, C, D, <span class="st">'BL'</span>)</span><span id="test_code-21"><a href="#test_code-21"></a><span class="bu">print</span>(np.allclose(iQ, np.linalg.inv(Q) ))</span><span id="test_code-22"><a href="#test_code-22"></a></span><span id="test_code-23"><a href="#test_code-23"></a></span><span id="test_code-24"><a href="#test_code-24"></a>A <span class="op">=</span> np.random.randn(<span class="dv">1</span>,<span class="dv">1</span>)</span><span id="test_code-25"><a href="#test_code-25"></a>B <span class="op">=</span> np.random.randn(<span class="dv">1</span>,<span class="dv">5</span>)</span><span id="test_code-26"><a href="#test_code-26"></a>C <span class="op">=</span> np.random.randn(<span class="dv">5</span>,<span class="dv">1</span>)</span><span id="test_code-27"><a href="#test_code-27"></a>D <span class="op">=</span> np.random.randn(<span class="dv">5</span>,<span class="dv">5</span>)</span><span id="test_code-28"><a href="#test_code-28"></a></span><span id="test_code-29"><a href="#test_code-29"></a>iQ <span class="op">=</span> np.linalg.inv(np.asarray(np.bmat( [[A, B],[C,D]] )))</span><span id="test_code-30"><a href="#test_code-30"></a>iD <span class="op">=</span> inverse_shrink(iQ, <span class="dv">5</span>, <span class="st">'BR'</span>)</span><span id="test_code-31"><a href="#test_code-31"></a><span class="bu">print</span>(np.allclose(iD, np.linalg.inv(D)))</span><span id="test_code-32"><a href="#test_code-32"></a></span><span id="test_code-33"><a href="#test_code-33"></a>iQ <span class="op">=</span> np.linalg.inv(np.asarray(np.bmat( [[D, C],[B,A]] )))</span><span id="test_code-34"><a href="#test_code-34"></a>iD <span class="op">=</span> inverse_shrink(iQ, <span class="dv">5</span>, <span class="st">'TL'</span>)</span><span id="test_code-35"><a href="#test_code-35"></a><span class="bu">print</span>(np.allclose(iD, np.linalg.inv(D)))</span><span id="test_code-36"><a href="#test_code-36"></a></span><span id="test_code-37"><a href="#test_code-37"></a>iQ <span class="op">=</span> np.linalg.inv(np.asarray(np.bmat( [[C, D],[A,B]] )))</span><span id="test_code-38"><a href="#test_code-38"></a>iD <span class="op">=</span> inverse_shrink(iQ, <span class="dv">5</span>, <span class="st">'TR'</span>)</span><span id="test_code-39"><a href="#test_code-39"></a><span class="bu">print</span>(np.allclose(iD, np.linalg.inv(D)))</span><span id="test_code-40"><a href="#test_code-40"></a></span><span id="test_code-41"><a href="#test_code-41"></a>iQ <span class="op">=</span> np.linalg.inv(np.asarray(np.bmat( [[B, A],[D,C]] )))</span><span id="test_code-42"><a href="#test_code-42"></a>iD <span class="op">=</span> inverse_shrink(iQ, <span class="dv">5</span>, <span class="st">'BL'</span>)</span><span id="test_code-43"><a href="#test_code-43"></a><span class="bu">print</span>(np.allclose(iD, np.linalg.inv(D)))</span></code></pre></div><h2 id="参考文献">参考文献</h2><div id="refs" class="references hanging-indent" role="doc-bibliography"><p><a href="https://www.zhihu.com/question/47760591" target="_blank" rel="noopener">知乎：如何求一个矩阵的逆</a></p><p><a href="http://www.cs.ubbcluj.ro/~csatol/SOGP/thesis/Iterative_computation.html" target="_blank" rel="noopener" class="uri">http://www.cs.ubbcluj.ro/~csatol/SOGP/thesis/Iterative_computation.html</a></p><div id="ref-cauwenberghs2001incremental"><p>Cauwenberghs, Gert, and Tomaso Poggio. 2001. “Incremental and Decremental Support Vector Machine Learning.” In <em>Advances in Neural Information Processing Systems</em>, 409–15.</p></div><div id="ref-wu2017online"><p>Wu, Chung-Hao, Wei-Chen His, Henry Horng-Shing Lu, and Hsueh-Ming Hang. 2017. “Online Multiclass Passive-Aggressive Learning on a Fixed Budget.” In <em>2017 Ieee International Symposium on Circuits and Systems (Iscas)</em>, 1–4. IEEE.</p></div></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python的GIL</title>
      <link href="/2020/03/15/python-de-gil/"/>
      <url>/2020/03/15/python-de-gil/</url>
      
        <content type="html"><![CDATA[<p>GIL全称Python Global Interpreter Lock，全局解释器锁。</p><h2 id="gil解决的问题">GIL解决的问题</h2><p>为了维护 python 变量的引用计数，该引用计数将用于垃圾收集。 同一进程内，多个解释器同时更新引用计数将产生竞争条件（race condition）。 在执行python字节码时需要保证线程安全。</p><h2 id="为何python选择了gil作为解决方案">为何Python选择了GIL作为解决方案</h2><ol type="1"><li>在操作系统还没有线程概念的时候，Python就已经出现了；</li><li>能提供线程安全的内存管理（垃圾收集）；</li><li>易于实现，是python早期的设计者们所采用的解决复杂问题的简单方法。</li></ol><h2 id="gil带来的问题">GIL带来的问题</h2><p>GIL的直接结果就是一个python进程只有一个解释器，从而导致一个python进程的多线程部分只能有一个解释器真正在执行。 对于CPU密集型任务，无法利用多核进行计算加速。</p><h2 id="如何避免">如何避免</h2><ol type="1"><li><p>使用多进程而不是多线程。即：使用multiprocessing库而不是自带的threading。前者启的是进程，后者启的是线程。</p></li><li><p>换用其他的py解释器。IronPython没有GIL。</p></li></ol><h2 id="参考">参考</h2><p><a href="https://realpython.com/python-gil/" target="_blank" rel="noopener" class="uri">https://realpython.com/python-gil/</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
