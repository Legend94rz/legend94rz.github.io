{"meta":{"title":"學而","subtitle":"学而时习之","description":"","author":"Legend94rz","url":"https://legend94rz.github.io","root":"/"},"pages":[{"title":"About","date":"2020-02-27T09:12:54.000Z","updated":"2020-03-17T12:30:32.567Z","comments":true,"path":"about/index.html","permalink":"https://legend94rz.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-03-16T08:28:28.000Z","updated":"2020-03-16T08:28:38.566Z","comments":true,"path":"categories/index.html","permalink":"https://legend94rz.github.io/categories/index.html","excerpt":"","text":""},{"title":"archives","date":"2020-03-16T09:46:54.000Z","updated":"2020-03-16T09:47:52.320Z","comments":true,"path":"archives/index.html","permalink":"https://legend94rz.github.io/archives/index.html","excerpt":"","text":"归档"},{"title":"contact","date":"2020-03-16T08:29:02.000Z","updated":"2020-03-16T08:29:09.117Z","comments":true,"path":"contact/index.html","permalink":"https://legend94rz.github.io/contact/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-03-16T08:28:05.000Z","updated":"2020-03-16T08:28:19.360Z","comments":true,"path":"tags/index.html","permalink":"https://legend94rz.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Windows环境下Python进程的启动过程","slug":"Windows环境下Python进程的启动过程","date":"2022-02-12T16:02:20.000Z","updated":"2022-02-13T03:12:17.625Z","comments":true,"path":"2022/0213/windows-huan-jing-xia-python-jin-cheng-de-qi-dong-guo-cheng/","link":"","permalink":"https://legend94rz.github.io/2022/0213/windows-huan-jing-xia-python-jin-cheng-de-qi-dong-guo-cheng/","excerpt":"","text":"从定义一个（包含错误的）自定义进程类开始： import multiprocessing as mp class MyProc(mp.Process): def __init__(self) -&gt; None: super().__init__() print(&#39;proc init&#39;) self.unpickle = lambda x: x+2 def run(self): print(&#39;subproc&#39;) print(self.unpickle) print(g) print(&#39;outside&#39;) if __name__ == &#39;__main__&#39;: print(&#39;main&#39;) g = random.random() p = MyProc() p.start() MyProc() 这里执行BaseProcess的构造函数，做一些变量赋值之类的操作，目前还是在主进程里。start函数真正启动一个子进程。 Process.Start() 做了什么 部分源码如下： class BaseProcess(object): def start(self): &#39;&#39;&#39; Start child process &#39;&#39;&#39; self._check_closed() assert self._popen is None, &#39;cannot start a process twice&#39; assert self._parent_pid == os.getpid(), \\ &#39;can only start a process object created by current process&#39; assert not _current_process._config.get(&#39;daemon&#39;), \\ &#39;daemonic processes are not allowed to have children&#39; _cleanup() self._popen = self._Popen(self) self._sentinel = self._popen.sentinel # Avoid a refcycle if the target function holds an indirect # reference to the process object (see bpo-30775) del self._target, se class Process(process.BaseProcess): _start_method = None @staticmethod def _Popen(process_obj): return _default_context.get_context().Process._Popen(process_obj) 关键是这一句 self._popen = self._Popen(self)，Process子类重载并实现了_Popen方法。在Windows平台上，context只有spawn一种，即通过WinAPI CreateProcess实现启动一个新进程。我们来看看具体是在哪儿、如何调用的。 在往下看之前，先明确几个变量是干什么的： _default_context.get_context() 这里先获得了一个SpawnContext对象，它只有一个比较重要的属性即Process。该属性是一个SpawnProcess对象，它是一个BaseProcess的子类，其中在_Popen方法构造了一个Popen实例，在该实例的构造函数里将实现对CreateProcess的调用。 参数process_obj即来自self._popen = self._Popen(self)中的self，是自定义进程类的一个实例。 涉及到的部分代码如下： class SpawnProcess(process.BaseProcess): _start_method = &#39;spawn&#39; @staticmethod def _Popen(process_obj): from .popen_spawn_win32 import Popen return Popen(process_obj) class SpawnContext(BaseContext): _name = &#39;spawn&#39; Process = SpawnProcess _concrete_contexts = { &#39;spawn&#39;: SpawnContext(), } _default_context = DefaultContext(_concrete_contexts[&#39;spawn&#39;]) 来看下Popen对象的构造函数： class Popen(object): &#39;&#39;&#39; Start a subprocess to run the code of a process object &#39;&#39;&#39; method = &#39;spawn&#39; def __init__(self, process_obj): prep_data = spawn.get_preparation_data(process_obj._name) # read end of pipe will be &quot;stolen&quot; by the child process # -- see spawn_main() in spawn.py. rhandle, whandle = _winapi.CreatePipe(None, 0) # 打开一个管道，分别拿到读句柄和写句柄 wfd = msvcrt.open_osfhandle(whandle, 0) # 构造启动命令行。结果形如：python -c &quot;from multiprocessing.spawn import spawn_main; spawn_main(xxx); --multiprocessing-fork&quot; cmd = spawn.get_command_line(parent_pid=os.getpid(), pipe_handle=rhandle) cmd = &#39; &#39;.join(&#39;&quot;%s&quot;&#39; % x for x in cmd) python_exe = spawn.get_executable() # bpo-35797: When running in a venv, we bypass the redirect # executor and launch our base Python. if WINENV and _path_eq(python_exe, sys.executable): python_exe = sys._base_executable env = os.environ.copy() env[&quot;__PYVENV_LAUNCHER__&quot;] = sys.executable else: env = None with open(wfd, &#39;wb&#39;, closefd=True) as to_child: # start process try: # 传入相同命令行，启动新进程，返回(新进程句柄、线程句柄、进程ID、线程ID)四元组。 hp, ht, pid, tid = _winapi.CreateProcess( python_exe, cmd, None, None, False, 0, env, None, None) _winapi.CloseHandle(ht) except: _winapi.CloseHandle(rhandle) raise # set attributes of self self.pid = pid self.returncode = None self._handle = hp self.sentinel = int(hp) self.finalizer = util.Finalize(self, _winapi.CloseHandle, (self.sentinel,)) # send information to child set_spawning_popen(self) try: reduction.dump(prep_data, to_child) # 以Pickle的方式，把自定义进程中的属性通过写管道发送给子进程。 reduction.dump(process_obj, to_child) finally: set_spawning_popen(None) 如何让新进程启动后去执行自定义类的run() 注意到，新进程的启动命令是一行python代码，它会执行spawn_main。然后查看spawn_main的源码可以发现它从管道中反序列化原进程对象，执行一些必要的初始化工作之后，最终通过Process._bootstrap调用Process.run。至此，一个新进程就启动起来了。 一个正确的自定义进程 可以看到，spawn方式启动不像fork那样，而是新启动一个进程，这个新进程并不会执行在if __name__ == '__main__'包围下的代码，因此全局变量g不会被管道发送；同时，MyProc.unpickle属性是一个lambda表达式，它是不能被序列化的，因此无法被发送到子进程。程序会执行失败。修改后的代码如下： import multiprocessing as mp class MyProc(mp.Process): def __init__(self) -&gt; None: super().__init__() print(&#39;proc init&#39;) def run(self): print(&#39;subproc&#39;) print(&#39;outside&#39;) if __name__ == &#39;__main__&#39;: print(&#39;main&#39;) g = random.random() p = MyProc() p.start()","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://legend94rz.github.io/tags/python/"}]},{"title":"簡化字整理","slug":"簡化字整理","date":"2020-03-25T03:45:17.000Z","updated":"2020-03-30T14:17:48.231Z","comments":true,"path":"2020/0325/jian-hua-zi-zheng-li/","link":"","permalink":"https://legend94rz.github.io/2020/0325/jian-hua-zi-zheng-li/","excerpt":"","text":"本文討論1984年国家语言文字工作委员会重新发表的簡化字總表，共分三個表：第一表共收簡化字350個，第二表共收簡化字132個以及14個簡化偏旁，第三表是應用第二表所列簡化字和簡化偏旁的出來的簡化字，共1753個。合計2235個簡化字。暫不討論1984年以前的簡化方案（一簡字）及廢除的第二次漢字簡化方案（二簡字）。 本文整理簡化字總表第一、二表中，簡化字與繁體字（下稱“正體字”）的對應關係、簡化方式等。 第一表（350字） table th:first-of-type { width: 5%; } table th:nth-of-type(2) { width: 5%; } table th:nth-of-type(3) { width: 30%; } table th:nth-of-type(4) { width: 25%; } table th:nth-of-type(5) { width: 35%; } 簡化方式為從俗的，一般可以在《宋元以來俗字譜》中找到，但是由于俗字譜并未給出釋義，無法確定俗寫字的讀音、含義是否發生變化，同時也不好查證是否屬於訛誤，應當謹慎看待。部分從俗字也可以在康熙字典中找到，這些可以明確含義、讀音。 正體字 簡化字 簡化方式 簡/正體音義差異情況 備注 礙 碍 從俗 （不詳） 骯 肮 假借/新造 音義不同 襖 袄 從俗/新造 （不詳） 壩 坝 新造/假借+偏旁類推 音同義不同 假借\"垻\"字，再由\"貝\"类推簡化 闆 板 假借 音同義不同 原用於\"木板\"、\"板凳\"等 辦 办 草書楷化 與之形體相近的寫法見于徐渭草書。 幫 帮 新造 寶 宝 從俗 （不詳） 《宋元以來俗字譜》 報 报 從俗 （不詳） 幣 币 假借/新造 音不同，義不詳 康熙字典備考字，同\"印 斃 毙 新造 標 标 從俗/新造 （不詳） 錶 表 本字 音同義不同 原意：與\"裏\"相對；表親；表明；表格；文體名，如《出師表》；標志；表揚等。 彆 别 假借 音同義不同 原讀陽平。原意：離別、分別；另外。 蔔 卜 假借 音義不同 原讀bu3。用於：占卜等。 補 补 從俗/新造 （不詳） 纔 才 從俗/假借/通假字 音同義不同 原意：才能；通\"材\"，資質，品質；通\"纔\"。 蠶 蚕 從俗/假借 音義部分相同 原讀tian3，指蚯蚓。讀can2時是\"蠶\"的俗體。 燦 灿 從俗/新造 （不詳） 層 层 草書楷化 攙 搀 從俗 （不詳） 讒 谗 從俗+偏旁類推 （不詳） 饞 馋 從俗+偏旁類推 （不詳） 纏 缠 從俗+偏旁類推 （不詳） 懺 忏 假借 音義不同 原讀qian3，怒也。Qian1：秦晉之間呼好為忏。 償 偿 草書楷化 廠 厂 新造/假借 音義不同 原讀han3：厂，山石之崖巖，人可居。 徹 彻 新造 塵 尘 古字 相同 襯 衬 從俗/新造 （不詳） 稱 称 從俗 （不詳） 懲 惩 從俗/新造 （不詳） 遲 迟 從俗/新造 （不詳） 衝 冲 假借 音同義不同 冲與沖同，原意：水湧動；空虛；幼小；直飛而上。 醜 丑 假借 音同義不同 原意：地支；丑時；戲劇角色名，丑角。 齣 出 本字 音同義不同 礎 础 新造 處 处 從俗 （不詳） 觸 触 假借 音義不同 原讀hong2，白魚赤尾者。 辭 辞 從俗 （不詳） 聰 聪 從俗 （不詳） 叢 丛 新造 擔 担 從俗 音義不同 Jie1: 高舉，放縱，引申為所願高遠；dan3: 擊；拂。 膽 胆 從俗 音義不同 Tan2: 口脂澤也；dan3: 肉胆也。 導 导 新造 燈 灯 從俗 （不詳） 鄧 邓 新造 敵 敌 從俗 糴 籴 從俗 遞 递 從俗 點 点 從俗 澱 淀 假借 音同義不同 原意：淺水湖泊。 電 电 新造 鼕 冬 假借 音同義不同 原指冬天。 鬥 斗 假借 音義不同 Dou3: 量器；古酒器；通\"陡\"；突然；通\"枓\"，斗拱；通\"抖\"，斗藪；星宿名。 獨 独 從俗 （不詳） 噸 吨 假借/新造 音義不同 原意：tun2/tun3，言不明也。 奪 夺 從俗 墮 堕 從俗 兒 儿 注音符号“ㄦ” 音義不同 注音符号“ㄦ”。古\"人\"字。 礬 矾 新造 範 范 假借 音同義不同 原意：草名；蟲名；通\"範\"、\"笵\"；通\"氾\"，氾濫；地名；姓，范仲淹、范雎。 飛 飞 新造 墳 坟 從俗 （不詳） 奮 奋 從俗 （不詳） 糞 粪 從俗 （不詳） 鳳 凤 從俗 （不詳） 膚 肤 從俗/新造 （不詳） 婦 妇 從俗 （不詳） 復、複 复 假借 音同義不同 原意：走老路。 蓋 盖 從俗 相同 乾、幹 干 假借 音部分相同，義不同 原意：gan1:盾；岸；犯；求；天干之一；若干；干涉。 趕 赶 從俗 音義部分相同 原意：qian2: 獸類翹著尾巴奔跑。Gan3: 急跑的樣子。 個 个 從俗 相同 個為後起字。 鞏 巩 從俗/新造 （不詳） 溝 沟 從俗 （不詳） 構 构 從俗 （不詳） 購 购 從俗+偏旁類推 音同義不同 從俗𧵈字，原意：治也。 穀 谷 假借 音部分相同，義不同 原意：gu3: 兩山之間的夾道或水道；深的坑穴；穴位；喻困境；通\"穀\"；lu4:谷蠡，匈奴藩王封號；yu4:吐谷渾，少數民族名。 顧 顾 草書楷化 颳 刮 本字 相同 本字再用，\"摩擦\"意。 關 关 從俗 （不詳） 觀 观 從俗+偏旁類推 （不詳） 櫃 柜 從俗/新造 音義不同 原意：ju1: 樹名；通\"矩\"，法度。 漢 汉 從俗/新造 （不詳） 號 号 從俗/假借 音部分相同，義不同 原意：hao4: 痛聲。 閤 合 本字 因相同，義部分相同 删减偏旁，本字再用。 轟 轰 從俗+偏旁類推 （不詳） 從俗字“𨋌”，再類推偏旁 後 后 假借 音同義不同 原意：君主；帝王之妻；通\"後\"。 鬍 胡 假借 音同義不同 獸類頜下作垂狀的肉；大；稱外族；疑問代詞；任意亂來； 壺 壶 草書楷化 滬 沪 從俗/新造 （不詳） 護 护 新造 劃 划 從俗/假借 音同義不同 原意：划水。 懷 怀 從俗 音義不同 原意：fu4: 怒也。 壞 坏 從俗 音義不同 原意：pi1: 土丘；未燒的陶器；pei2: 用泥塗塞空隙；屋的後墻。 歡 欢 從俗 （不詳） 環 环 從俗 （不詳） 還 还 從俗 音義不同 原讀：fu2/fou3 迴 回 從俗 （不詳） 夥 伙 從俗/新造 （不詳） 獲、穫 获 從俗/新造 （不詳） 擊 击 新造 鷄 鸡 從俗+偏旁類推 相同 從俗字\"鳮\"，再類推偏旁 積 积 從俗/新造 音不同，義不詳 原見於康熙字典備考字，音枳。 極 极 從俗/新造 音同義不同 原意：驢背上用以駝物的架子。 際 际 從俗/新造 （不詳） 繼 继 草書楷化 傢 家 本字 音同義不同 價 价 假借 音義不同 原意：jie4: 价人，善人；使者，來价，來使。 艱 艰 從俗/新造 （不詳） 殲 歼 從俗/新造 （不詳） 繭 茧 假借/新造 音義不同 原意：zhong1，同\"𦬕\"，草衰也。 揀 拣 草書楷化 鹼 硷 從俗/新造 （不詳） 同\"碱\"。 艦 舰 從俗/新造 （不詳） 薑 姜 假借 音同義不同 原意：姓。 漿 浆 從俗/新造 （不詳） 槳 桨 從俗/新造 （不詳） 奬 奖 從俗/新造 （不詳） 講 讲 從俗/新造 （不詳） 醬 酱 從俗/新造 （不詳） 膠 胶 從俗/假借 音義不同 原意：xiao2: 聲也；脛骨也。 階 阶 從俗/新造 （不詳） 癤 疖 從俗/新造 （不詳） 潔 洁 從俗/新造/假借 音義不同 原意：ji2: 水名。 藉 借 從俗/假借 音部分相同，義不同 使，命令。 僅 仅 從俗/新造/假借 音義不同 原意：同\"付\"；以手持物也。 驚 惊 從俗/新造 音義不同 原意：liang2: 悲也。或作悢、𢝋。 競 竞 新造 舊 旧 新造 劇 剧 新造 據 据 從俗/假借 （不詳） 原意：ju1:拮据；ju4:通\"據\"，依據；通\"倨\"，傲慢。 懼 惧 從俗/新造 （不詳） 卷、捲 卷 本字 音義部分相同 原意：quan2: 曲；juan3: 捲起來；juan4:書卷。 開 开 從俗/新造 （不詳） 剋 克 本字 音義部分相同 原意：ke4: 能；勝；克期，約定日期。注：在\"能\"的意義上只能寫\"克\"，克勤克儉；在\"勝\"的意義上一般也只作\"克\"。 墾 垦 從俗/新造/假借 音不同，義不詳 康熙字典備考字，同\"垠\" 懇 恳 從俗/新造 誇 夸 本字 音義部分相同 原意：kua1: 奢侈；自大，炫耀。 塊 块 從俗/新造/假借 音不同，義不詳 康熙字典備考字，音\"月\"。 虧 亏 從俗/新造 音義不同 原意：于也。 睏 困 本字 音義部分相同 原意：kun4: 艱難，窘迫；貧乏；勞倦。 臘 腊 從俗/假借 音義不同 原意：xi1: 乾肉；皮膚乾裂。 蠟 蜡 從俗/假借 音義不同 原意：qu1: 蛆的古體；蜡氏，古官名；zha4: 通\"䄍\"，祭名。 蘭 兰 新造 攔 拦 新造 欄 栏 新造 爛 烂 新造 纍 累 從俗/假借 音義部分相同 原意：lei3: 堆集，積聚；時間上相接續；空間上相重叠；增加；連累，牽連；lei4: 勞累，煩勞；纍贅，禍害；lei2: 繩索；拘繫，捆綁。 壘 垒 從俗 （不詳） 類 类 從俗 （不詳） 裏 里 從俗 音同義不同 原意：li3: 宅院；長度單位；語氣詞。 禮 礼 古字 相同 禮的古字。 隸 隶 從俗/假借 音義不同 原意：dai4:同\"逮\" 簾 帘 從俗/假借 音同義不同 原意：lian2:酒家用作店招的旗幟。 聯 联 草書楷化 憐 怜 從俗/假借 音義部分相同 原意：ling2: 機靈；lian2: 同\"憐\"。 煉 炼 草書楷化 練 练 草書楷化 糧 粮 從俗 （不詳） 療 疗 從俗/新造 （不詳） 遼 辽 從俗/新造 （不詳） 瞭 了 從俗/假借 音義部分相同 原意：liao3: 了結；明白。 獵 猎 從俗/假借 音義不同 原意：ji2,xi1: 獸名，似熊；que4: 宋良犬，名猎猎。 臨 临 草書楷化 見於徐浩草書。 鄰 邻 新造 嶺 岭 從俗/假借 音義不同 原意：ling2: 山深貌。 廬 庐 從俗 （不詳） 蘆 芦 從俗/假借 音義不同 爐 炉 從俗 相同 陸 陆 草書楷化 驢 驴 從俗+偏旁類推 相同 先從俗字“馿”，再类推偏旁 亂 乱 從俗 相同 麽 么 從俗/假借 音義不同 黴 霉 從俗 相同 蒙、矇、濛、懞 蒙 從俗 音義部分相同 夢 梦 從俗 相同 面、麵 面 從俗/假借 音同義不同 廟 庙 從俗 相同 滅 灭 新造 衊 蔑 從俗/本字 音部分相同，義不同 畝 亩 從俗 （不詳） 惱 恼 草書楷化 腦 脑 草書楷化 擬 拟 從俗/新造 （不詳） 釀 酿 從俗/新造 （不詳） 瘧 疟 從俗/新造 （不詳） 盤 盘 從俗/新造 （不詳） 辟、闢 辟 假借/本字 音義部分相同 苹、蘋 苹 假借 音義不同 蘋：pin1，水草名。 憑 凭 從俗/本字 音義部分相同 撲 扑 從俗 音義部分相同 僕 仆 從俗/假借 音義不同 樸 朴 從俗/假借 音義部分相同 啓 启 從俗/本字 相同 簽、籤 签 從俗+偏旁類推 音同，義部分相同 簽、籤含義稍有不同。 千、韆 千 從俗/假借/本字 音同義不同 牽 牵 從俗/新造 （不詳） 縴、纖 纤 新造 竅 窍 新造 竊 窃 從俗/新造 （不詳） 寢 寝 從俗/新造 （不詳） 慶 庆 新造 瓊 琼 從俗/新造 （不詳） 秋、鞦 秋 從俗/假借/本字 音同義不同 曲、麯 曲 假借/本字 音義部分相同 權 权 新造 勸 劝 新造 确、確 确 本字 音義部分相同 讓 让 新造 擾 扰 新造/假借 音義不同 熱 热 新造 認 认 新造 灑 洒 從俗 音義部分相同 傘 伞 新造 喪 丧 從俗/新造 （不詳） 掃 扫 從俗/新造 （不詳） 澀 涩 新造 曬 晒 從俗/本字 相同 傷 伤 從俗/新造 （不詳） 舍、捨 舍 假借 音義部分相同 沈、瀋 沈 假借 音義部分相同 聲 声 從俗 相同 胜、勝 胜 假借 音義不同 濕 湿 新造 先從俗\"𣺯\"；《宋元以來俗字譜》 實 实 草書楷化 適 适 假借 音義不同 勢 势 從俗 （不詳） 獸 兽 新造 書 书 草書楷化 术、術 术 新造/假借 音義不同 疑先假借\"朮\"字，再簡化 樹 树 新造 帥 帅 新造 松、鬆 松 假借 音部分相同，義不同 蘇、囌 苏 新造 雖 虽 從俗 （不詳） 隨 随 從俗 音義部分相同 見於古代碑帖 台、臺、檯、颱 台 假借 音部分相同，義不同 四字有别 態 态 新造 壇、罎 坛 從俗/新造 （不詳） 嘆 叹 新造 謄 誊 新造 体、體 体 從俗/假借 音義不同 “体”原爲“笨”之異體 糶 粜 從俗 相同 鐵 铁 從俗/假借 音義不同 “鉄”的类推簡化；《宋元以來俗字譜》 聽 听 從俗 音義不同 《宋元以來俗字譜》 廳 厅 從俗 （不詳） 《宋元以來俗字譜》 頭 头 新造 “头”原为“貫”之俗字、草书 圖 图 新造 塗 涂 新造/假借 音部分相同，義不同 團、糰 团 新造/假借 音不同，義不詳 团是康熙字典備考字，音\"囚\" 橢 椭 新造 窪 洼 假借 音義部分相同 襪 袜 假借 音義部分相同 網 网 古字 衛 卫 新造 从日本传入；符号代替 穩 稳 從俗 （不詳） 《宋元以來俗字譜》 務 务 新造 霧 雾 新造 犧 牺 新造 習 习 新造 系、係、繫 系 假借 音義部分相同 系、係同音，有捆綁、連接之意，可以通用；擊在讀xi4時也可與系通用，還可讀ji4，打結。區別：世系、繫辭。 戲 戏 新造 蝦 虾 新造 嚇 吓 新造 鹹 咸 假借 音部分相同，義不同 顯 显 新造 先從俗\"㫫\"；《宋元以來俗字譜》 憲 宪 新造/假借 音不同，義不詳 宪是康熙字典備考字，xiong4 縣 县 新造 響 响 新造 向、嚮 向 古字 音義部分相同 向，古嚮字。嚮讀xiang4時與向同；讀xiang3時，與\"享饗響\"通假。 協 协 新造 脅 胁 新造 褻 亵 新造 釁 衅 假借 相同 興 兴 草書楷化 須、鬚 须 假借 音義部分相同 鬚，僅用於鬍鬚 懸 悬 新造 選 选 新造 鏇 旋 假借 音義部分相同 壓 压 新造 鹽 盐 新造 陽 阳 從俗 相同 《宋元以來俗字譜》 養 养 從俗 （不詳） 《宋元以來俗字譜》 癢 痒 從俗 音義不同 《宋元以來俗字譜》 樣 样 新造/假借 音義不同 鑰 钥 新造/假借+偏旁類推 音部分相同，義不同 疑假借\"鈅\"字 葯、藥 药 新造/假借 音義不同 爺 爷 新造 葉 叶 假借 音義不同 醫 医 從俗/假借 音義不同 億 亿 新造 憶 忆 新造 應 应 草書楷化 从俗 癰 痈 新造 擁 拥 新造 傭 佣 新造 踴 踊 古字 相同 踴是踊的後起異體字。古漢語字典 憂 忧 新造/假借 音義不同 優 优 新造/假借 音義不同 优，康熙字典補遺。 郵 邮 新造/假借 音同義不同 余、餘 余 假借 音同義不同 御、禦 御 假借 音義部分相同 禦yu4: 祭祀；抗拒，抵擋；通\"御\" 吁、籲 吁 假借 音不同，義部分相同 籲yu4: 呼也。 郁、鬱 郁 假借 音同義不同 誉、譽 誉 從俗/新造 （不詳） 淵 渊 新造 園 园 從俗 （不詳） 《宋元以來俗字譜》 遠 远 從俗 （不詳） 《宋元以來俗字譜》 願 愿 假借 音同義不同 躍 跃 新造 運 运 新造/假借 音義不同 醖 酝 新造 雜 杂 新造 贓 赃 新造 臓、髒 脏 新造 鑿 凿 新造 棗 枣 從俗 （不詳） 《宋元以來俗字譜》 竈 灶 從俗 相同 齋 斋 從俗 相同 氈 毡 從俗 相同 戰 战 新造 趙 赵 新造 摺 折 假借 音部分相同，義不同 折：折斷；曲折等。摺：摺叠。 這 这 從俗 音義部分相同 《宋元以來俗字譜》 征、徵 征 假借 音部分相同，義不同 症、癥 症 假借 音義不同 証、證 证 假借+偏旁類推 音義不同 假借\"証\"字 只、隻、衹 只 假借 音部分相同，義不同 只：zhi3: 語氣詞；副詞，祗，僅僅。祗：zhi3: 僅僅；qi2:地神；大；通\"疧\"，病也。隻：zhi1: 量词；shuang1: 通\"雙\"。 致、緻 致 假借 音同義不同 製 制 假借 音同義不同 法制；制裁；制度；製作； 鍾、鐘 钟 新造/假借 音義部分相同 钟假借鈡字，是康熙字典備考字，音中。鐘：zhong1: 樂器；古計量單位，也作鍾。鍾：zhong1: 酒壺；容量單位；聚集；當；通\"鐘\"。 腫 肿 新造 種 种 新造/假借 音義不同 衆 众 假借 音義不同 晝 昼 從俗 （不詳） 《宋元以來俗字譜》 朱、硃 朱 假借 音同，義部分相同 硃：zhu1: 後起字，硃砂；朱墨寫的文字。朱：zhu1: 樹名；大紅色；硃砂。 燭 烛 從俗/新造/假借 音義不同 《宋元以來俗字譜》烛字为俗寫；康熙字典：俗作燭字，非。 築 筑 假借 音義不同 莊 庄 新造/假借 音義不同 樁 桩 新造 妝 妆 新造 裝 装 新造 壯 壮 新造 狀 状 新造 準 准 假借 音同，義部分相同 准：zhun3: 取平的工具；鼻子；箭靶；古公文用語。凖：zhun3: 水平；平物的量器；標準；矯正樂律的古樂器；準確；准許；箭靶；鼻子。 濁 浊 新造/假借 （不詳） 《宋元以來俗字譜》 總 总 從俗 （不詳） 《宋元以來俗字譜》 鑽 钻 新造/假借+偏旁類推 音義不同 假借\"鉆\"字 第二表（132字） 正體字 簡化字 簡化方式 簡/正體音義差異情況 備注 愛 爱 新造 罷 罢 從俗 （不詳） 《宋元以來俗字譜》 備 备 新造 貝 贝 草書楷化 筆 笔 假借 相同 康熙字典 畢 毕 新造 邊 边 從俗 （不詳） 《宋元以來俗字譜》 賓 宾 從俗 （不詳） 《宋元以來俗字譜》 參 参 新造 倉 仓 新造 產 产 新造 長 长 草書楷化 嘗 尝 草書楷化 車 车 草書楷化 齒 齿 新造 蟲 虫 從俗/假借 音義不同 《宋元以來俗字譜》；康熙字典：若《六書正譌》以爲虫即蟲省文，則大謬也。 芻 刍 新造 從 从 本字 相同 竄 窜 新造 達 达 假借 音義部分相同 帶 带 草書楷化 單 单 草書楷化 當、噹 当 草書楷化 黨 党 假借 音同義不同 東 东 草書楷化 動 动 新造 斷 断 草書楷化 對 对 新造 隊 队 新造 爾 尔 假借/古字 相同 發、髮 发 草書楷化 豐 丰 假借 音同義不同 風 风 新造 岡 冈 新造 廣 广 新造 歸 归 新造 龜 龟 草書楷化 國 国 從俗/新造 （不詳） 《宋元以來俗字譜》中，囗内是王。 過 过 從俗 （不詳） 《宋元以來俗字譜》 華 华 新造 畫 画 假接 相同 匯、彙 汇 新造 會 会 草書楷化 幾 几 假借 音義不同 夾 夹 新造 戔 戋 新造 監 监 草書楷化/新造 見 见 草書楷化 薦 荐 假借 音義部分相同 將 将 從俗 相同 節 节 從俗/新造 （不詳） 《宋元以來俗字譜》 盡、儘 尽 草書楷化 進 进 新造 擧 举 新造 殻 壳 新造 疑應爲\"殼\"字，康熙字典、古漢語字典無\"殻\"字。 來 来 從俗/假借 相同 樂 乐 新造 離 离 假借 音義部分相同 歷、曆 历 新造 麗 丽 古字 兩 两 新造 靈 灵 從俗/新造 相同 與《宋元以來俗字譜》中形體一致。康熙字典的俗字\"灵\"，上部是出头的。 劉 刘 從俗 （不詳） 《宋元以來俗字譜》 龍 龙 新造 婁 娄 草書楷化 盧 卢 新造 虜 虏 新造 鹵、滷 卤 新造/假借 音義不同 卤為籀文𠧧（西）字。 録 录 新造 慮 虑 新造/假借 音義不同 侖 仑 新造/草書楷化 羅 罗 從俗 （不詳） 《宋元以來俗字譜》 馬 马 新造 買 买 新造 賣 卖 草書楷化 麥 麦 從俗 相同 門 门 草書楷化 黽 黾 從俗 相同 難 难 從俗 （不詳） 《宋元以來俗字譜》 鳥 鸟 從俗/新造 （不詳） 《宋元以來俗字譜》，形體不完全一致。 聶 聂 新造 寧 宁 新造/假借 音義不同 農 农 草書楷化 齊 齐 新造 豈 岂 草書楷化 氣 气 古字 相同 遷 迁 從俗 相同 僉 佥 草書楷化 喬 乔 從俗 （不詳） 《宋元以來俗字譜》 親 亲 從俗 （不詳） 《宋元以來俗字譜》 窮 穷 從俗 （不詳） 《宋元以來俗字譜》 區 区 新造 嗇 啬 新造 殺 杀 新造 審 审 新造 聖 圣 從俗 音義不同 《宋元以來俗字譜》；康熙字典：圣，音ku1。 師 师 新造 時 时 從俗 （不詳） 《宋元以來俗字譜》 壽 寿 草書楷化 屬 属 從俗 相同 雙 双 從俗 相同 康熙字典：雙俗作双，非。 肅 肃 新造 歲 岁 新造 孫 孙 草書楷化 條 条 從俗 （不詳） 《宋元以來俗字譜》 萬 万 假借 音義部分相同 《古漢語字典》：万作萬字，古書中罕見。 爲 为 草書楷化 韋 韦 草書楷化 烏 乌 新造 無 无 假借 相同 獻 献 從俗 相同 鄉 乡 新造 寫 写 草書楷化 尋 寻 新造 亞 亚 草書楷化 嚴 严 新造 厭 厌 新造 堯 尧 草書楷化 業 业 新造 頁 页 草書楷化 義 义 新造 藝 艺 新造 陰 阴 從俗 相同 隱 隐 從俗 （不詳） 《宋元以來俗字譜》 猶 犹 假借 音義不同 魚 鱼 草書楷化 與 与 草書楷化 雲 云 假借 音同義不同 鄭 郑 從俗 （不詳） 《宋元以來俗字譜》 執 执 從俗 （不詳） 《宋元以來俗字譜》 質 质 從俗 （不詳） 《宋元以來俗字譜》 專 专 草書楷化 參考文獻 知乎：那些糟糕的簡化字(A-C) 知乎：那些糟糕的簡化字(D-Z) 國學大師/康熙字典/王力古漢語字典 《宋元以來俗字譜》 简化字总表第一表 简化字总表第二表","categories":[{"name":"漢語言","slug":"漢語言","permalink":"https://legend94rz.github.io/categories/%E6%BC%A2%E8%AA%9E%E8%A8%80/"}],"tags":[{"name":"漢字","slug":"漢字","permalink":"https://legend94rz.github.io/tags/%E6%BC%A2%E5%AD%97/"}]},{"title":"矩阵增量式求逆","slug":"矩阵增量式求逆","date":"2020-03-15T04:11:42.000Z","updated":"2020-03-29T05:50:39.172Z","comments":true,"path":"2020/0315/ju-zhen-zeng-liang-shi-qiu-ni/","link":"","permalink":"https://legend94rz.github.io/2020/0315/ju-zhen-zeng-liang-shi-qiu-ni/","excerpt":"","text":"本文只讨论 狭义的可逆矩阵，首先必须是方阵。 背景&amp;动机 暴力求一个矩阵的逆，时间复杂度是\\(O(n^3)\\)，太高了。如果这个矩阵会随着时间越长越大，每长一次就要求一次逆，如何降低计算开销？再如果这个矩阵不光变大，还有可能缩小，又如何处理？ 一个典型的场景是在线计算核矩阵的逆(Wu et al. 2017; Cauwenberghs and Poggio 2001)。 背景知识 假设某可逆矩阵，分为\\(A,B,C,D\\)四块，则有公式可以计算该分块矩阵的逆。按照子矩阵形状的不同，可分为如下两种情况： 公式有点多，不要怕，真的 \\(A, D\\)为方阵： \\[ \\begin{align} \\begin{split} \\left[ \\begin{array}{cc} A &amp; B \\\\ C &amp; D \\\\ \\end{array} \\right]^{-1} &amp;= \\left[ \\begin{array}{cc} A^{-1}+A^{-1}BFCA^{-1} &amp; -A^{-1}BF \\\\ -FCA^{-1} &amp; F \\\\ \\end{array} \\right]\\\\ \\text{where}\\qquad F&amp;=(D-CA^{-1}B)^{-1} \\end{split} \\end{align} \\qquad(1)\\] 公式 1 等价于： \\[ \\begin{align} \\begin{split} \\left[ \\begin{array}{cc} A &amp; B \\\\ C &amp; D \\\\ \\end{array} \\right]^{-1} &amp;= \\left[ \\begin{array}{cc} E &amp; -EBD^{-1} \\\\ -D^{-1}CE &amp; D^{-1}+D^{-1}CEBD^{-1} \\\\ \\end{array} \\right]\\\\ \\text{where}\\qquad E&amp;=(A-BD^{-1}C)^{-1} \\end{split} \\end{align} \\qquad(2)\\] \\(B, C\\)为方阵： \\[ \\begin{align} \\begin{split} \\left[ \\begin{array}{cc} A &amp; B \\\\ C &amp; D \\\\ \\end{array} \\right]^{-1} &amp;= \\left[ \\begin{array}{cc} -GDB^{-1} &amp; G \\\\ B^{-1}+B^{-1}AGDB^{-1} &amp; -BAG \\\\ \\end{array} \\right]\\\\ \\text{where}\\qquad G&amp;=(C-DB^{-1}A)^{-1} \\end{split} \\end{align} \\qquad(3)\\] 公式 3 也有等价形式： \\[ \\begin{align} \\begin{split} \\left[ \\begin{array}{cc} A &amp; B \\\\ C &amp; D \\\\ \\end{array} \\right]^{-1} &amp;= \\left[ \\begin{array}{cc} -C^{-1}DH &amp; C^{-1}+C^{-1}DHAC^{-1} \\\\ H &amp; -HAC^{-1} \\\\ \\end{array} \\right]\\\\ \\text{where}\\qquad H&amp;=(B-AC^{-1}D)^{-1} \\end{split} \\end{align} \\qquad(4)\\] 如何做 有了上述四个公式，即可增量计算矩阵逆。举例如下： 假设现在有一矩阵 \\(A\\in\\mathbb{R}^{n\\times n}\\)，已知其逆矩阵 \\(A^{-1}\\)，如果：在\\(A\\)右侧添加子矩阵\\(B\\in\\mathbb{R}^{n\\times m}\\)，下方添加子矩阵\\(C\\in\\mathbb{R}^{m\\times n}\\)，右下方添加子矩阵\\(D\\in\\mathbb{R}^{m\\times m}\\)，构成大矩阵 \\(A&#39;\\in\\mathbb{R}^{(n+m)\\times (n+m)}\\)，求\\(A&#39;\\)的逆。 这个问题是矩阵扩张的情形，可以直接应用 公式 1 解决。那么问题反过来，缩小如何解决？ 已知矩阵\\(A&#39;\\in\\mathbb{R}^{n\\times n}\\)是矩阵\\(A\\)的逆，若在\\(A\\)（以及\\(A&#39;\\)）的左上两边各舍弃\\(m\\)列，求\\(A\\)剩下的子矩阵的逆。 稍微多了点步骤，这相当于：已知 公式 2 的右边，删去了左上角的\\(m\\)行/列，求\\(D^{-1}\\)。还可以注意到： \\(A&#39;\\) 剩下的东西就相当于是 公式 2 右边的 \\(D^{-1}+D^{-1}CEBD^{-1}\\) 左边删去的相当于是\\(-D^{-1}CE\\) 上边删去的相当于是 \\(-EBD^{-1}\\) 左上角删去的是 \\(E\\) 另外把 \\(D^{-1}C\\) 与 \\(BD^{-1}\\) 分别看成整体，可以建立方程组求出\\(D^{-1}\\)来： \\[ \\begin{split} \\text{左上删去的部分} = E \\\\ -[D^{-1}C]E = \\text{左边删去的} \\\\ -E[BD^{-1}] = \\text{上边删去的} \\\\ D^{-1} = \\text{剩下的} - [D^{-1}C]E[BD^{-1}] \\end{split} \\] 把\\(D^{-1}C\\)、\\(BD^{-1}\\)当整体解出来，带到第4个公式里，即可得到\\(D^{-1}\\)。 总结 前面举例介绍了在已知矩阵的右下角新增行列时如何求逆，以及从已知矩阵的左上角删除行列时如何求逆。分别是 公式 1 正用， 公式 2 反用的情况。 不难发现，公式 1-4 正着用就分别适用于已知 \\(A^{-1}, D^{-1}, B^{-1}, C^{-1}\\)，求大矩阵的逆；而反着用就分别适用于已知大矩阵的逆，求对应剩余部分的逆的情况。当然了，这样做省时间的前提是要\\(m\\ll n\\)，不然求\\(m\\times m\\)大小的矩阵的逆也是很花时间的，得不偿失了。 def inverse_enlarge(iA, B, C, D, where=&#39;TL&#39;): &#39;&#39;&#39; 已知iA为某方阵A的逆，在A周围新添加BCD三块，组成新方阵。返回该新方阵的逆。 where: 指示iA的位置，即在大方阵的哪个角。 BCD的位置按照如下原则：A与B在同一行。A的对角是D。剩余的是C。A与D始终是方阵。 &#39;&#39;&#39; assert(iA.shape[0]==B.shape[0]) assert(iA.shape[1]==C.shape[1]) assert(D.shape[0]==C.shape[0]) assert(D.shape[1]==B.shape[1]) assert(iA.shape[0]==iA.shape[1] and D.shape[0]==D.shape[1]) F = np.linalg.inv(D-C@iA@B) Ap = iA+iA@B@F@C@iA Bp = -iA@B@F Cp = -F@C@iA if where == &#39;BR&#39;: return np.asarray(np.bmat([[F, Cp],[Bp, Ap]])) elif where == &#39;TL&#39;: return np.asarray(np.bmat([[Ap, Bp],[Cp, F]])) elif where == &#39;TR&#39;: return np.asarray(np.bmat([[Cp, F],[Ap, Bp]])) else: assert(where == &#39;BL&#39;) return np.asarray(np.bmat([[Bp, Ap],[F, Cp]])) def inverse_shrink(V, m, where=&#39;BR&#39;): &#39;&#39;&#39; 已知V为某分块矩阵的逆，求某个子方阵的逆。限制：V与要求的子矩阵都必须是方阵。 V: 已知的逆矩阵 m: 返回值大小为&lt;m x m&gt; where: 返回值在大矩阵的哪个角。 &#39;&#39;&#39; assert(V.shape[0]==V.shape[1] and V.shape[0]&gt;m&gt;0) if where==&#39;BR&#39;: F, Cp, Bp, X = V[:-m, :-m], V[:-m, -m:], V[-m:, :-m], V[-m:, -m:] elif where==&#39;TL&#39;: X, Bp, Cp, F = V[:m, :m], V[:m, m:], V[m:, :m], V[m:, m:] elif where==&#39;TR&#39;: m = V.shape[0]-m Cp, F, X, Bp = V[:m, :-m], V[:m, -m:], V[m:, :-m], V[m:, -m:] else: assert(where==&#39;BL&#39;) m = V.shape[0]-m Bp, X, F, Cp = V[:-m, :m], V[:-m, m:], V[-m:, :m], V[-m:, m:] tmp = np.linalg.inv(F) CiA = tmp@Cp iAB = Bp@tmp iA = X-iAB@F@CiA return iA 测试代码 A = np.random.randn(5,5) B = np.random.randn(5,1) C = np.random.randn(1,5) D = np.random.randn(1,1) iA = np.linalg.inv(A) Q = np.asarray(np.bmat( [[D, C],[B,A]] )) iQ = inverse_enlarge(iA, B, C, D, &#39;BR&#39;) print(np.allclose(iQ, np.linalg.inv(Q) )) Q = np.asarray(np.bmat( [[A, B],[C,D]] )) iQ = inverse_enlarge(iA, B, C, D, &#39;TL&#39;) print(np.allclose(iQ, np.linalg.inv(Q) )) Q = np.asarray(np.bmat( [[B, A],[D,C]] )) iQ = inverse_enlarge(iA, B, C, D, &#39;TR&#39;) print(np.allclose(iQ, np.linalg.inv(Q) )) Q = np.asarray(np.bmat( [[C, D],[A,B]] )) iQ = inverse_enlarge(iA, B, C, D, &#39;BL&#39;) print(np.allclose(iQ, np.linalg.inv(Q) )) A = np.random.randn(1,1) B = np.random.randn(1,5) C = np.random.randn(5,1) D = np.random.randn(5,5) iQ = np.linalg.inv(np.asarray(np.bmat( [[A, B],[C,D]] ))) iD = inverse_shrink(iQ, 5, &#39;BR&#39;) print(np.allclose(iD, np.linalg.inv(D))) iQ = np.linalg.inv(np.asarray(np.bmat( [[D, C],[B,A]] ))) iD = inverse_shrink(iQ, 5, &#39;TL&#39;) print(np.allclose(iD, np.linalg.inv(D))) iQ = np.linalg.inv(np.asarray(np.bmat( [[C, D],[A,B]] ))) iD = inverse_shrink(iQ, 5, &#39;TR&#39;) print(np.allclose(iD, np.linalg.inv(D))) iQ = np.linalg.inv(np.asarray(np.bmat( [[B, A],[D,C]] ))) iD = inverse_shrink(iQ, 5, &#39;BL&#39;) print(np.allclose(iD, np.linalg.inv(D))) 参考文献 知乎：如何求一个矩阵的逆 http://www.cs.ubbcluj.ro/~csatol/SOGP/thesis/Iterative_computation.html Cauwenberghs, Gert, and Tomaso Poggio. 2001. “Incremental and Decremental Support Vector Machine Learning.” In Advances in Neural Information Processing Systems, 409–15. Wu, Chung-Hao, Wei-Chen His, Henry Horng-Shing Lu, and Hsueh-Ming Hang. 2017. “Online Multiclass Passive-Aggressive Learning on a Fixed Budget.” In 2017 Ieee International Symposium on Circuits and Systems (Iscas), 1–4. IEEE.","categories":[],"tags":[{"name":"math","slug":"math","permalink":"https://legend94rz.github.io/tags/math/"}]},{"title":"Python的GIL","slug":"Python的GIL","date":"2020-03-15T04:10:29.000Z","updated":"2020-03-17T04:51:44.215Z","comments":true,"path":"2020/0315/python-de-gil/","link":"","permalink":"https://legend94rz.github.io/2020/0315/python-de-gil/","excerpt":"","text":"GIL全称Python Global Interpreter Lock，全局解释器锁。 GIL解决的问题 为了维护 python 变量的引用计数，该引用计数将用于垃圾收集。 同一进程内，多个解释器同时更新引用计数将产生竞争条件（race condition）。 在执行python字节码时需要保证线程安全。 为何Python选择了GIL作为解决方案 在操作系统还没有线程概念的时候，Python就已经出现了； 能提供线程安全的内存管理（垃圾收集）； 易于实现，是python早期的设计者们所采用的解决复杂问题的简单方法。 GIL带来的问题 GIL的直接结果就是一个python进程只有一个解释器，从而导致一个python进程的多线程部分只能有一个解释器真正在执行。 对于CPU密集型任务，无法利用多核进行计算加速。 如何避免 使用多进程而不是多线程。即：使用multiprocessing库而不是自带的threading。前者启的是进程，后者启的是线程。 换用其他的py解释器。IronPython没有GIL。 参考 https://realpython.com/python-gil/","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://legend94rz.github.io/tags/python/"}]}]}