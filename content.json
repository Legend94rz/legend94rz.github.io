{"meta":{"title":"學而","subtitle":"学而时习之","description":"","author":"Legend94rz","url":"https://legend94rz.github.io","root":"/"},"pages":[{"title":"archives","date":"2020-03-16T09:46:54.000Z","updated":"2020-03-16T09:47:52.320Z","comments":true,"path":"archives/index.html","permalink":"https://legend94rz.github.io/archives/index.html","excerpt":"","text":"归档"},{"title":"categories","date":"2020-03-16T08:28:28.000Z","updated":"2020-03-16T08:28:38.566Z","comments":true,"path":"categories/index.html","permalink":"https://legend94rz.github.io/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2020-02-27T09:12:54.000Z","updated":"2020-03-17T12:30:32.567Z","comments":true,"path":"about/index.html","permalink":"https://legend94rz.github.io/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-03-16T08:28:05.000Z","updated":"2020-03-16T08:28:19.360Z","comments":true,"path":"tags/index.html","permalink":"https://legend94rz.github.io/tags/index.html","excerpt":"","text":""},{"title":"contact","date":"2020-03-16T08:29:02.000Z","updated":"2020-03-16T08:29:09.117Z","comments":true,"path":"contact/index.html","permalink":"https://legend94rz.github.io/contact/index.html","excerpt":"","text":""}],"posts":[{"title":"矩阵增量式求逆","slug":"矩阵增量式求逆","date":"2020-03-15T04:11:42.000Z","updated":"2020-03-18T07:49:04.671Z","comments":true,"path":"2020/03/15/ju-zhen-zeng-liang-shi-qiu-ni/","link":"","permalink":"https://legend94rz.github.io/2020/03/15/ju-zhen-zeng-liang-shi-qiu-ni/","excerpt":"","text":"本文只讨论 狭义的可逆矩阵，首先必须是方阵。 背景&amp;动机 暴力求一个矩阵的逆，时间复杂度是\\(O(n^3)\\)，太高了。如果这个矩阵会随着时间越长越大，每长一次就要求一次逆，如何降低计算开销？再如果这个矩阵不光变大，还有可能缩小，又如何处理？ 一个典型的场景是在线计算核矩阵的逆(Wu et al. 2017; Cauwenberghs and Poggio 2001)。 背景知识 假设某可逆矩阵，分为\\(A,B,C,D\\)四块，则有公式可以计算该分块矩阵的逆。按照子矩阵形状的不同，可分为如下两种情况： 公式有点多，不要怕，真的 \\(A, D\\)为方阵： \\[ \\begin{align} \\begin{split} \\left[ \\begin{array}{cc} A &amp; B \\\\ C &amp; D \\\\ \\end{array} \\right]^{-1} &amp;= \\left[ \\begin{array}{cc} A^{-1}+A^{-1}BFCA^{-1} &amp; -A^{-1}BF \\\\ -FCA^{-1} &amp; F \\\\ \\end{array} \\right]\\\\ \\text{where}\\qquad F&amp;=(D-CA^{-1}B)^{-1} \\end{split} \\end{align} \\qquad(1)\\] 公式 1 等价于： \\[ \\begin{align} \\begin{split} \\left[ \\begin{array}{cc} A &amp; B \\\\ C &amp; D \\\\ \\end{array} \\right]^{-1} &amp;= \\left[ \\begin{array}{cc} E &amp; -EBD^{-1} \\\\ -D^{-1}CE &amp; D^{-1}+D^{-1}CEBD^{-1} \\\\ \\end{array} \\right]\\\\ \\text{where}\\qquad E&amp;=(A-BD^{-1}C)^{-1} \\end{split} \\end{align} \\qquad(2)\\] \\(B, C\\)为方阵： \\[ \\begin{align} \\begin{split} \\left[ \\begin{array}{cc} A &amp; B \\\\ C &amp; D \\\\ \\end{array} \\right]^{-1} &amp;= \\left[ \\begin{array}{cc} -GDB^{-1} &amp; G \\\\ B^{-1}+B^{-1}AGDB^{-1} &amp; -BAG \\\\ \\end{array} \\right]\\\\ \\text{where}\\qquad G&amp;=(C-DB^{-1}A)^{-1} \\end{split} \\end{align} \\qquad(3)\\] 公式 3 也有等价形式： \\[ \\begin{align} \\begin{split} \\left[ \\begin{array}{cc} A &amp; B \\\\ C &amp; D \\\\ \\end{array} \\right]^{-1} &amp;= \\left[ \\begin{array}{cc} -C^{-1}DH &amp; C^{-1}+C^{-1}DHAC^{-1} \\\\ H &amp; -HAC^{-1} \\\\ \\end{array} \\right]\\\\ \\text{where}\\qquad H&amp;=(B-AC^{-1}D)^{-1} \\end{split} \\end{align} \\qquad(4)\\] 如何做 有了上述四个公式，即可增量计算矩阵逆。举例如下： 假设现在有一矩阵 \\(A\\in\\mathbb{R}^{n\\times n}\\)，已知其逆矩阵 \\(A^{-1}\\)，如果：在\\(A\\)右侧添加子矩阵\\(B\\in\\mathbb{R}^{n\\times m}\\)，下方添加子矩阵\\(C\\in\\mathbb{R}^{m\\times n}\\)，右下方添加子矩阵\\(D\\in\\mathbb{R}^{m\\times m}\\)，构成大矩阵 \\(A&#39;\\in\\mathbb{R}^{(n+m)\\times (n+m)}\\)，求\\(A&#39;\\)的逆。 这个问题是矩阵扩张的情形，可以直接应用 公式 1 解决。那么问题反过来，缩小如何解决？ 已知矩阵\\(A&#39;\\in\\mathbb{R}^{n\\times n}\\)是矩阵\\(A\\)的逆，若在\\(A\\)（以及\\(A&#39;\\)）的左上两边各舍弃\\(m\\)列，求\\(A\\)剩下的子矩阵的逆。 稍微多了点步骤，这相当于：已知 公式 2 的右边，删去了左上角的\\(m\\)行/列，求\\(D^{-1}\\)。还可以注意到： * \\(A&#39;\\) 剩下的东西就相当于是 公式 2 右边的 \\(D^{-1}+D^{-1}CEBD^{-1}\\) * 左边删去的相当于是\\(-D^{-1}CE\\) * 上边删去的相当于是 \\(-EBD^{-1}\\) * 左上角删去的是 \\(E\\) 另外把 \\(D^{-1}C\\) 与 \\(BD^{-1}\\) 分别看成整体，可以建立方程组求出\\(D^{-1}\\)来： \\[ \\begin{split} \\text{左上删去的部分} = E \\\\ -[D^{-1}C]E = \\text{左边删去的} \\\\ -E[BD^{-1}] = \\text{上边删去的} \\\\ D^{-1} = \\text{剩下的} - [D^{-1}C]E[BD^{-1}] \\end{split} \\] 把\\(D^{-1}C\\)、\\(BD^{-1}\\)当整体解出来，带到第4个公式里，即可得到\\(D^{-1}\\)。 总结 前面举例介绍了在已知矩阵的右下角新增行列时如何求逆，以及从已知矩阵的左上角删除行列时如何求逆。分别是 公式 1 正用， 公式 2 反用的情况。 不难发现，公式 1-4 正着用就分别适用于已知 \\(A^{-1}, D^{-1}, B^{-1}, C^{-1}\\)，求大矩阵的逆；而反着用就分别适用于已知大矩阵的逆，求对应剩余部分的逆的情况。当然了，这样做省时间的前提是要\\(m\\ll n\\)，不然求\\(m\\times m\\)大小的矩阵的逆也是很花时间的，得不偿失了。 def inverse_enlarge(iA, B, C, D, where=&#39;TL&#39;): &#39;&#39;&#39; 已知iA为某方阵A的逆，在A周围新添加BCD三块，组成新方阵。返回该新方阵的逆。 where: 指示iA的位置，即在大方阵的哪个角。 BCD的位置按照如下原则：A与B在同一行。A的对角是D。剩余的是C。A与D始终是方阵。 &#39;&#39;&#39; assert(iA.shape[0]==B.shape[0]) assert(iA.shape[1]==C.shape[1]) assert(D.shape[0]==C.shape[0]) assert(D.shape[1]==B.shape[1]) assert(iA.shape[0]==iA.shape[1] and D.shape[0]==D.shape[1]) F = np.linalg.inv(D-C@iA@B) Ap = iA+iA@B@F@C@iA Bp = -iA@B@F Cp = -F@C@iA if where == &#39;BR&#39;: return np.asarray(np.bmat([[F, Cp],[Bp, Ap]])) elif where == &#39;TL&#39;: return np.asarray(np.bmat([[Ap, Bp],[Cp, F]])) elif where == &#39;TR&#39;: return np.asarray(np.bmat([[Cp, F],[Ap, Bp]])) else: assert(where == &#39;BL&#39;) return np.asarray(np.bmat([[Bp, Ap],[F, Cp]])) def inverse_shrink(V, m, where=&#39;BR&#39;): &#39;&#39;&#39; 已知V为某分块矩阵的逆，求某个子方阵的逆。限制：V与要求的子矩阵都必须是方阵。 V: 已知的逆矩阵 m: 返回值大小为&lt;m x m&gt; where: 返回值在大矩阵的哪个角。 &#39;&#39;&#39; assert(V.shape[0]==V.shape[1] and V.shape[0]&gt;m&gt;0) if where==&#39;BR&#39;: F, Cp, Bp, X = V[:-m, :-m], V[:-m, -m:], V[-m:, :-m], V[-m:, -m:] elif where==&#39;TL&#39;: X, Bp, Cp, F = V[:m, :m], V[:m, m:], V[m:, :m], V[m:, m:] elif where==&#39;TR&#39;: m = V.shape[0]-m Cp, F, X, Bp = V[:m, :-m], V[:m, -m:], V[m:, :-m], V[m:, -m:] else: assert(where==&#39;BL&#39;) m = V.shape[0]-m Bp, X, F, Cp = V[:-m, :m], V[:-m, m:], V[-m:, :m], V[-m:, m:] tmp = np.linalg.inv(F) CiA = tmp@Cp iAB = Bp@tmp iA = X-iAB@F@CiA return iA 测试代码 A = np.random.randn(5,5) B = np.random.randn(5,1) C = np.random.randn(1,5) D = np.random.randn(1,1) iA = np.linalg.inv(A) Q = np.asarray(np.bmat( [[D, C],[B,A]] )) iQ = inverse_enlarge(iA, B, C, D, &#39;BR&#39;) print(np.allclose(iQ, np.linalg.inv(Q) )) Q = np.asarray(np.bmat( [[A, B],[C,D]] )) iQ = inverse_enlarge(iA, B, C, D, &#39;TL&#39;) print(np.allclose(iQ, np.linalg.inv(Q) )) Q = np.asarray(np.bmat( [[B, A],[D,C]] )) iQ = inverse_enlarge(iA, B, C, D, &#39;TR&#39;) print(np.allclose(iQ, np.linalg.inv(Q) )) Q = np.asarray(np.bmat( [[C, D],[A,B]] )) iQ = inverse_enlarge(iA, B, C, D, &#39;BL&#39;) print(np.allclose(iQ, np.linalg.inv(Q) )) A = np.random.randn(1,1) B = np.random.randn(1,5) C = np.random.randn(5,1) D = np.random.randn(5,5) iQ = np.linalg.inv(np.asarray(np.bmat( [[A, B],[C,D]] ))) iD = inverse_shrink(iQ, 5, &#39;BR&#39;) print(np.allclose(iD, np.linalg.inv(D))) iQ = np.linalg.inv(np.asarray(np.bmat( [[D, C],[B,A]] ))) iD = inverse_shrink(iQ, 5, &#39;TL&#39;) print(np.allclose(iD, np.linalg.inv(D))) iQ = np.linalg.inv(np.asarray(np.bmat( [[C, D],[A,B]] ))) iD = inverse_shrink(iQ, 5, &#39;TR&#39;) print(np.allclose(iD, np.linalg.inv(D))) iQ = np.linalg.inv(np.asarray(np.bmat( [[B, A],[D,C]] ))) iD = inverse_shrink(iQ, 5, &#39;BL&#39;) print(np.allclose(iD, np.linalg.inv(D))) 参考文献 知乎：如何求一个矩阵的逆 http://www.cs.ubbcluj.ro/~csatol/SOGP/thesis/Iterative_computation.html Cauwenberghs, Gert, and Tomaso Poggio. 2001. “Incremental and Decremental Support Vector Machine Learning.” In Advances in Neural Information Processing Systems, 409–15. Wu, Chung-Hao, Wei-Chen His, Henry Horng-Shing Lu, and Hsueh-Ming Hang. 2017. “Online Multiclass Passive-Aggressive Learning on a Fixed Budget.” In 2017 Ieee International Symposium on Circuits and Systems (Iscas), 1–4. IEEE.","categories":[],"tags":[{"name":"math","slug":"math","permalink":"https://legend94rz.github.io/tags/math/"}]},{"title":"Python的GIL","slug":"Python的GIL","date":"2020-03-15T04:10:29.000Z","updated":"2020-03-17T04:51:44.215Z","comments":true,"path":"2020/03/15/python-de-gil/","link":"","permalink":"https://legend94rz.github.io/2020/03/15/python-de-gil/","excerpt":"","text":"GIL全称Python Global Interpreter Lock，全局解释器锁。 GIL解决的问题 为了维护 python 变量的引用计数，该引用计数将用于垃圾收集。 同一进程内，多个解释器同时更新引用计数将产生竞争条件（race condition）。 在执行python字节码时需要保证线程安全。 为何Python选择了GIL作为解决方案 在操作系统还没有线程概念的时候，Python就已经出现了； 能提供线程安全的内存管理（垃圾收集）； 易于实现，是python早期的设计者们所采用的解决复杂问题的简单方法。 GIL带来的问题 GIL的直接结果就是一个python进程只有一个解释器，从而导致一个python进程的多线程部分只能有一个解释器真正在执行。 对于CPU密集型任务，无法利用多核进行计算加速。 如何避免 使用多进程而不是多线程。即：使用multiprocessing库而不是自带的threading。前者启的是进程，后者启的是线程。 换用其他的py解释器。IronPython没有GIL。 参考 https://realpython.com/python-gil/","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://legend94rz.github.io/tags/python/"}]}]}